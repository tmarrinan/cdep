/**
 * Bundled by jsDelivr using Rollup v2.74.1 and Terser v5.15.1.
 * Original file: /npm/@petamoriken/float16@3.8.0/src/index.mjs
 *
 * Do NOT use SRI with dynamically generated files! More information: https://www.jsdelivr.com/using-sri-with-dynamic-files
 */
function t(t){return(n,...r)=>e(t,n,r)}function n(n,e){return t(s(n,e).get)}const{apply:e,construct:r,defineProperty:o,get:i,getOwnPropertyDescriptor:s,getPrototypeOf:c,has:u,ownKeys:f,set:h,setPrototypeOf:l}=Reflect,a=Proxy,{MAX_SAFE_INTEGER:y,isFinite:w,isNaN:p}=Number,{iterator:d,species:g,toStringTag:v,for:b}=Symbol,A=Object,{create:x,defineProperty:m,freeze:_,is:E}=A,T=A.prototype,B=T.__lookupGetter__?t(T.__lookupGetter__):(t,n)=>{if(null==t)throw bt("Cannot convert undefined or null to object");let e=A(t);do{const t=s(e,n);if(void 0!==t)return j(t,"get")?t.get:void 0}while(null!==(e=c(e)))},j=A.hasOwn||t(T.hasOwnProperty),O=Array,S=O.isArray,P=O.prototype,R=t(P.join),F=t(P.push),I=t(P.toLocaleString),L=P[d],k=t(L),C=Math.trunc,N=ArrayBuffer,U=N.isView,M=N.prototype,D=t(M.slice),W=n(M,"byteLength"),G="undefined"!=typeof SharedArrayBuffer?SharedArrayBuffer:null,V=G&&n(G.prototype,"byteLength"),Y=c(Uint8Array),z=Y.from,K=Y.prototype,X=K[d],q=t(K.keys),H=t(K.values),J=t(K.entries),Q=t(K.set),Z=t(K.reverse),$=t(K.fill),tt=t(K.copyWithin),nt=t(K.sort),et=t(K.slice),rt=t(K.subarray),ot=n(K,"buffer"),it=n(K,"byteOffset"),st=n(K,"length"),ct=n(K,v),ut=Uint16Array,ft=(...t)=>e(z,ut,t),ht=Uint32Array,lt=Float32Array,at=c([][d]()),yt=t(at.next),wt=t(function*(){}().next),pt=c(at),dt=DataView.prototype,gt=t(dt.getUint16),vt=t(dt.setUint16),bt=TypeError,At=RangeError,xt=WeakSet,mt=xt.prototype,_t=t(mt.add),Et=t(mt.has),Tt=WeakMap,Bt=Tt.prototype,jt=t(Bt.get),Ot=t(Bt.has),St=t(Bt.set),Pt=new Tt,Rt=x(null,{next:{value:function(){const t=jt(Pt,this);return yt(t)}},[d]:{value:function(){return this}}});function Ft(t){if(t[d]===L&&at.next===yt)return t;const n=x(Rt);return St(Pt,n,k(t)),n}const It=new Tt,Lt=x(pt,{next:{value:function(){const t=jt(It,this);return wt(t)},writable:!0,configurable:!0}});for(const t of f(at))"next"!==t&&m(Lt,t,s(at,t));function kt(t){const n=x(Lt);return St(It,n,t),n}function Ct(t){return null!==t&&"object"==typeof t||"function"==typeof t}function Nt(t){return null!==t&&"object"==typeof t}function Ut(t){return void 0!==ct(t)}function Mt(t){const n=ct(t);return"BigInt64Array"===n||"BigUint64Array"===n}function Dt(t){return!!S(t)&&(t[d]===L&&at.next===yt)}function Wt(t){if("string"!=typeof t)return!1;const n=+t;return t===n+""&&(!!w(n)&&n===C(n))}const Gt=b("__Float16Array__");const Vt=new N(4),Yt=new lt(Vt),zt=new ht(Vt),Kt=new ht(512),Xt=new ht(512);for(let t=0;t<256;++t){const n=t-127;n<-27?(Kt[t]=0,Kt[256|t]=32768,Xt[t]=24,Xt[256|t]=24):n<-14?(Kt[t]=1024>>-n-14,Kt[256|t]=1024>>-n-14|32768,Xt[t]=-n-1,Xt[256|t]=-n-1):n<=15?(Kt[t]=n+15<<10,Kt[256|t]=n+15<<10|32768,Xt[t]=13,Xt[256|t]=13):n<128?(Kt[t]=31744,Kt[256|t]=64512,Xt[t]=24,Xt[256|t]=24):(Kt[t]=31744,Kt[256|t]=64512,Xt[t]=13,Xt[256|t]=13)}function qt(t){Yt[0]=t;const n=zt[0],e=n>>23&511;return Kt[e]+((8388607&n)>>Xt[e])}const Ht=new ht(2048),Jt=new ht(64),Qt=new ht(64);for(let t=1;t<1024;++t){let n=t<<13,e=0;for(;0==(8388608&n);)n<<=1,e-=8388608;n&=-8388609,e+=947912704,Ht[t]=n|e}for(let t=1024;t<2048;++t)Ht[t]=939524096+(t-1024<<13);for(let t=1;t<31;++t)Jt[t]=t<<23;Jt[31]=1199570944,Jt[32]=2147483648;for(let t=33;t<63;++t)Jt[t]=2147483648+(t-32<<23);Jt[63]=3347054592;for(let t=1;t<64;++t)32!==t&&(Qt[t]=1024);function Zt(t){const n=t>>10;return zt[0]=Ht[Qt[n]+(1023&t)]+Jt[n],Yt[0]}function $t(t){const n=+t;return p(n)||0===n?0:C(n)}function tn(t){const n=$t(t);return n<0?0:n<y?n:y}function nn(t,n){if(!Ct(t))throw bt("This is not an object");const e=t.constructor;if(void 0===e)return n;if(!Ct(e))throw bt("The constructor property value is not an object");const r=e[g];return null==r?n:r}function en(t){if(function(t){if(null===G)return!1;try{return V(t),!0}catch(t){return!1}}(t))return!1;try{return D(t,0,0),!1}catch(t){}return!0}function rn(t,n){const e=p(t),r=p(n);if(e&&r)return 0;if(e)return 1;if(r)return-1;if(t<n)return-1;if(t>n)return 1;if(0===t&&0===n){const e=E(t,0),r=E(n,0);if(!e&&r)return-1;if(e&&!r)return 1}return 0}const on=new Tt;function sn(t){return Ot(on,t)||!U(t)&&function(t){if(!Nt(t))return!1;const n=c(t);if(!Nt(n))return!1;const e=n.constructor;if(void 0===e)return!1;if(!Ct(e))throw bt("The constructor property value is not an object");return u(e,Gt)}(t)}function cn(t){if(!sn(t))throw bt("This is not a Float16Array object")}function un(t,n){const e=sn(t),r=Ut(t);if(!e&&!r)throw bt("Species constructor didn't return TypedArray object");if("number"==typeof n){let r;if(e){const n=fn(t);r=st(n)}else r=st(t);if(r<n)throw bt("Derived constructor created TypedArray object which was too small length")}if(Mt(t))throw bt("Cannot mix BigInt and other types, use explicit conversions")}function fn(t){const n=jt(on,t);if(void 0!==n){if(en(ot(n)))throw bt("Attempting to access detached ArrayBuffer");return n}const e=t.buffer;if(en(e))throw bt("Attempting to access detached ArrayBuffer");const o=r(yn,[e,t.byteOffset,t.length],t.constructor);return jt(on,o)}function hn(t){const n=st(t),e=[];for(let r=0;r<n;++r)e[r]=Zt(t[r]);return e}const ln=new xt;for(const t of f(K)){if(t===v)continue;const n=s(K,t);j(n,"get")&&"function"==typeof n.get&&_t(ln,n.get)}const an=_({get:(t,n,e)=>Wt(n)&&j(t,n)?Zt(i(t,n)):Et(ln,B(t,n))?i(t,n):i(t,n,e),set:(t,n,e,r)=>Wt(n)&&j(t,n)?h(t,n,qt(e)):h(t,n,e,r),getOwnPropertyDescriptor(t,n){if(Wt(n)&&j(t,n)){const e=s(t,n);return e.value=Zt(e.value),e}return s(t,n)},defineProperty:(t,n,e)=>Wt(n)&&j(t,n)&&j(e,"value")?(e.value=qt(e.value),o(t,n,e)):o(t,n,e)});class yn{constructor(t,n,e){let o;if(sn(t))o=r(ut,[fn(t)],new.target);else if(Ct(t)&&!function(t){try{return W(t),!0}catch(t){return!1}}(t)){let n,e;if(Ut(t)){n=t,e=st(t);if(en(ot(t)))throw bt("Attempting to access detached ArrayBuffer");if(Mt(t))throw bt("Cannot mix BigInt and other types, use explicit conversions");const i=new N(2*e);o=r(ut,[i],new.target)}else{const i=t[d];if(null!=i&&"function"!=typeof i)throw bt("@@iterator property is not callable");null!=i?Dt(t)?(n=t,e=t.length):(n=[...t],e=n.length):(n=t,e=tn(n.length)),o=r(ut,[e],new.target)}for(let t=0;t<e;++t)o[t]=qt(n[t])}else o=r(ut,arguments,new.target);const i=new a(o,an);return St(on,i,o),i}static from(t,...n){const r=this;if(!u(r,Gt))throw bt("This constructor is not a subclass of Float16Array");if(r===yn){if(sn(t)&&0===n.length){const n=fn(t),e=new ut(ot(n),it(n),st(n));return new yn(ot(et(e)))}if(0===n.length)return new yn(ot(ft(t,qt)));const r=n[0],o=n[1];return new yn(ot(ft(t,(function(t,...n){return qt(e(r,this,[t,...Ft(n)]))}),o)))}let o,i;const s=t[d];if(null!=s&&"function"!=typeof s)throw bt("@@iterator property is not callable");if(null!=s)Dt(t)?(o=t,i=t.length):Ut(c=t)&&c[d]===X&&at.next===yt?(o=t,i=st(t)):(o=[...t],i=o.length);else{if(null==t)throw bt("Cannot convert undefined or null to object");o=A(t),i=tn(o.length)}var c;const f=new r(i);if(0===n.length)for(let t=0;t<i;++t)f[t]=o[t];else{const t=n[0],r=n[1];for(let n=0;n<i;++n)f[n]=e(t,r,[o[n],n])}return f}static of(...t){const n=this;if(!u(n,Gt))throw bt("This constructor is not a subclass of Float16Array");const e=t.length;if(n===yn){const n=new yn(e),r=fn(n);for(let n=0;n<e;++n)r[n]=qt(t[n]);return n}const r=new n(e);for(let n=0;n<e;++n)r[n]=t[n];return r}keys(){cn(this);const t=fn(this);return q(t)}values(){cn(this);const t=fn(this);return kt(function*(){for(const n of H(t))yield Zt(n)}())}entries(){cn(this);const t=fn(this);return kt(function*(){for(const[n,e]of J(t))yield[n,Zt(e)]}())}at(t){cn(this);const n=fn(this),e=st(n),r=$t(t),o=r>=0?r:e+r;if(!(o<0||o>=e))return Zt(n[o])}with(t,n){cn(this);const e=fn(this),r=st(e),o=$t(t),i=o>=0?o:r+o,s=+n;if(i<0||i>=r)throw At("Offset is out of bounds");const c=new ut(ot(e),it(e),st(e)),u=new yn(ot(et(c)));return fn(u)[i]=qt(s),u}map(t,...n){cn(this);const r=fn(this),o=st(r),i=n[0],s=nn(r,yn);if(s===yn){const n=new yn(o),s=fn(n);for(let n=0;n<o;++n){const o=Zt(r[n]);s[n]=qt(e(t,i,[o,n,this]))}return n}const c=new s(o);un(c,o);for(let n=0;n<o;++n){const o=Zt(r[n]);c[n]=e(t,i,[o,n,this])}return c}filter(t,...n){cn(this);const r=fn(this),o=st(r),i=n[0],s=[];for(let n=0;n<o;++n){const o=Zt(r[n]);e(t,i,[o,n,this])&&F(s,o)}const c=new(nn(r,yn))(s);return un(c),c}reduce(t,...n){cn(this);const e=fn(this),r=st(e);if(0===r&&0===n.length)throw bt("Reduce of empty array with no initial value");let o,i;0===n.length?(o=Zt(e[0]),i=1):(o=n[0],i=0);for(let n=i;n<r;++n)o=t(o,Zt(e[n]),n,this);return o}reduceRight(t,...n){cn(this);const e=fn(this),r=st(e);if(0===r&&0===n.length)throw bt("Reduce of empty array with no initial value");let o,i;0===n.length?(o=Zt(e[r-1]),i=r-2):(o=n[0],i=r-1);for(let n=i;n>=0;--n)o=t(o,Zt(e[n]),n,this);return o}forEach(t,...n){cn(this);const r=fn(this),o=st(r),i=n[0];for(let n=0;n<o;++n)e(t,i,[Zt(r[n]),n,this])}find(t,...n){cn(this);const r=fn(this),o=st(r),i=n[0];for(let n=0;n<o;++n){const o=Zt(r[n]);if(e(t,i,[o,n,this]))return o}}findIndex(t,...n){cn(this);const r=fn(this),o=st(r),i=n[0];for(let n=0;n<o;++n){const o=Zt(r[n]);if(e(t,i,[o,n,this]))return n}return-1}findLast(t,...n){cn(this);const r=fn(this),o=st(r),i=n[0];for(let n=o-1;n>=0;--n){const o=Zt(r[n]);if(e(t,i,[o,n,this]))return o}}findLastIndex(t,...n){cn(this);const r=fn(this),o=st(r),i=n[0];for(let n=o-1;n>=0;--n){const o=Zt(r[n]);if(e(t,i,[o,n,this]))return n}return-1}every(t,...n){cn(this);const r=fn(this),o=st(r),i=n[0];for(let n=0;n<o;++n)if(!e(t,i,[Zt(r[n]),n,this]))return!1;return!0}some(t,...n){cn(this);const r=fn(this),o=st(r),i=n[0];for(let n=0;n<o;++n)if(e(t,i,[Zt(r[n]),n,this]))return!0;return!1}set(t,...n){cn(this);const e=fn(this),r=$t(n[0]);if(r<0)throw At("Offset is out of bounds");if(null==t)throw bt("Cannot convert undefined or null to object");if(Mt(t))throw bt("Cannot mix BigInt and other types, use explicit conversions");if(sn(t))return Q(fn(this),fn(t),r);if(Ut(t)){if(en(ot(t)))throw bt("Attempting to access detached ArrayBuffer")}const o=st(e),i=A(t),s=tn(i.length);if(r===1/0||s+r>o)throw At("Offset is out of bounds");for(let t=0;t<s;++t)e[t+r]=qt(i[t])}reverse(){cn(this);const t=fn(this);return Z(t),this}toReversed(){cn(this);const t=fn(this),n=new ut(ot(t),it(t),st(t)),e=new yn(ot(et(n))),r=fn(e);return Z(r),e}fill(t,...n){cn(this);const e=fn(this);return $(e,qt(t),...Ft(n)),this}copyWithin(t,n,...e){cn(this);const r=fn(this);return tt(r,t,n,...Ft(e)),this}sort(t){cn(this);const n=fn(this),e=void 0!==t?t:rn;return nt(n,((t,n)=>e(Zt(t),Zt(n)))),this}toSorted(t){cn(this);const n=fn(this);if(void 0!==t&&"function"!=typeof t)throw new bt("The comparison function must be either a function or undefined");const e=void 0!==t?t:rn,r=new ut(ot(n),it(n),st(n)),o=new yn(ot(et(r))),i=fn(o);return nt(i,((t,n)=>e(Zt(t),Zt(n)))),o}slice(t,n){cn(this);const e=fn(this),r=nn(e,yn);if(r===yn){const r=new ut(ot(e),it(e),st(e));return new yn(ot(et(r,t,n)))}const o=st(e),i=$t(t),s=void 0===n?o:$t(n);let c,u;c=i===-1/0?0:i<0?o+i>0?o+i:0:o<i?o:i,u=s===-1/0?0:s<0?o+s>0?o+s:0:o<s?o:s;const f=u-c>0?u-c:0,h=new r(f);if(un(h,f),0===f)return h;if(en(ot(e)))throw bt("Attempting to access detached ArrayBuffer");let l=0;for(;c<u;)h[l]=Zt(e[c]),++c,++l;return h}subarray(t,n){cn(this);const e=fn(this),r=nn(e,yn),o=new ut(ot(e),it(e),st(e)),i=rt(o,t,n),s=new r(ot(i),it(i),st(i));return un(s),s}indexOf(t,...n){cn(this);const e=fn(this),r=st(e);let o=$t(n[0]);if(o===1/0)return-1;o<0&&(o+=r,o<0&&(o=0));for(let n=o;n<r;++n)if(j(e,n)&&Zt(e[n])===t)return n;return-1}lastIndexOf(t,...n){cn(this);const e=fn(this),r=st(e);let o=n.length>=1?$t(n[0]):r-1;if(o===-1/0)return-1;o>=0?o=o<r-1?o:r-1:o+=r;for(let n=o;n>=0;--n)if(j(e,n)&&Zt(e[n])===t)return n;return-1}includes(t,...n){cn(this);const e=fn(this),r=st(e);let o=$t(n[0]);if(o===1/0)return!1;o<0&&(o+=r,o<0&&(o=0));const i=p(t);for(let n=o;n<r;++n){const r=Zt(e[n]);if(i&&p(r))return!0;if(r===t)return!0}return!1}join(t){cn(this);const n=hn(fn(this));return R(n,t)}toLocaleString(...t){cn(this);const n=hn(fn(this));return I(n,...Ft(t))}get[v](){if(sn(this))return"Float16Array"}}m(yn,"BYTES_PER_ELEMENT",{value:2}),m(yn,Gt,{}),l(yn,Y);const wn=yn.prototype;function pn(t){return Ut(t)||sn(t)}function dn(t,n,...e){return Zt(gt(t,n,...Ft(e)))}function gn(t,n,e,...r){return vt(t,n,qt(e),...Ft(r))}function vn(t){const n=+t;if(!w(n)||0===n)return n;return Zt(qt(n))}m(wn,"BYTES_PER_ELEMENT",{value:2}),m(wn,d,{value:wn.values,writable:!0,configurable:!0}),l(wn,K);export{yn as Float16Array,vn as f16round,dn as getFloat16,vn as hfround,sn as isFloat16Array,pn as isTypedArray,gn as setFloat16};export default null;